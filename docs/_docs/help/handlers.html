<html>
<head>
  <title>Request Handlers</title>
  <link rel="stylesheet" type="text/css" href="docstyle.css"/>
</head>
<body>
<h1>Request Handlers</h1>
A handler is a Java or Kotlin class implementing the <a href="../javadoc/com/centurylink/mdw/request/RequestHandler.html">RequestHandler</a> interface.
Handlers are registered via the <a href="../javadoc/com/centurylink/mdw/annotations/Handler.html">@Handler</a> annotation,
and they're invoked when an external message is received that matches the <code>path</code> annotation parameter.

<h2>Request Matching</h2>
Incoming requests are matched against potential handlers per two possible routing patterns:
<ul>
  <li>
    <strong>Path</strong> routing: Match according to request endpoint path (<a href="../javadoc/com/centurylink/mdw/request/RequestHandler.Routing.html#Path">Routing.Path</a>).
  </li>
  <li>
    <strong>Content</strong> routing: Match according to request content via XPath or JSON expression (<a href="../javadoc/com/centurylink/mdw/request/RequestHandler.Routing.html#Content">Routing.Content</a>).
  </li>
</ul>

Typically a request handler will interpret the message payload and do one of the following:
<ul>
  <li>Run a workflow process</li>
  <li>Notify a waiting process</li>
  <li>Respond directly through programmatic logic</li>
</ul>
Handlers commonly may perform other tasks as well:
<ul>
  <li>Validate the request</li>
  <li>Determine master request ID</li>
  <li>Populate process input values</li>
  <li>Create an acknowledgment response</li>
</ul>

<h2>Base Handlers</h2>

  MDW provides two built-in external event handlers, one for starting processes
  (<code>com.centurylink.mdw.listener.ProcessStartEventHandler</code>) as well
  as invoking processes as services,
  and the other for sending messages to existing process instances
  (<code>com.centurylink.mdw.listener.<code>NotifyWaitingActivityEventHandler</code></code>).
</li>

The external event handlers (including the built-in ones)
must be configured through the Designer so that
the listeners know which one to use for an incoming message.

<h2><a id="externalEventHandlers">Configuring External Event Handlers</h2>
External event handlers are configured as assets with <em>.evth as their extension.
  Each entry contains an event pattern and an event handler specification.</em>
<p>
  The event pattern that defines which incoming messages are handled can be path-driven
  or content-driven.  Here's the general pattern for an evth file:
<pre>
{
  "handlerClass": [class name or START_PROCESS, etc],
  "path": [request path or xpath expression (for content-based),
  "routing": "path|content"
}
</pre>
</p>
<p>
  Content-based paths are described using a variant of the XPath language that is name-space
  agnostic. See <a href="xpath.html">this link</a> for MDW XPath language
  examples and syntax.
<p>
  The handler specification is typically a fully qualified class name. It may also
  take additional parameters which resembles URL parameter syntax, as in
<pre>
	com.centurylink.mdw.listener.ProcessStartEventHandler?ProcessName=MyProcess
</pre>
If there is more than one parameter, they are delimited by "&amp;".
<p>
  Since the standard process start event handler may be used very often, there is a syntax abbreviation
  supported, where you can use "START_PROCESS" in place of the class name, so the following specification
  is equivalent to the one above:
<pre>
    START_PROCESS?ProcessName=MyProcess&MasterRequestID={//Order/OrderNumber}
</pre>
Similarly, there is a syntax abbreviation for the built-in event hander
<code>NotifyWaitingActivityEventHandler</code>, which is <code>NOTIFY_PROCESS</code>.
An example of its usage is (description of its syntax will be described later):
<pre>
    NOTIFY_PROCESS?EventName=ServiceOrder{//OrderType}{//OrderNumber}
</pre>
</br>

<h2>Built-In Event Handlers</h2>

<h3>Built-In Process Start Event Handler</h3>
The event handler,
<a href="../javadoc/com/centurylink/mdw/listener/ProcessStartEventHandler.html">
  <code>com.centurylink.mdw.listener.ProcessStartEventHandler</code></a>,
can be used to start an asynchronous (regular) process or
invoke a synchronous (service) process as service.

When the process to be started is a regular process (see <a href="process.html">
  this link</a> for introduction on regular vs. service processes),
it performs the following things:
<ul>
  <li>It finds the most recent version of the process definition
    for the process name specified as the parameter <code>ProcessName</code>
    in the external event handler specification (see below)</li>
  <li>If the parameter <code>MasterRequestID</code> is specified,
    use it as the master request ID (after replacing place holders with
    actual values). Otherwise use external event instance ID
    as the master request ID.</li>
  <li>It populates and sends a process start message
    to the process controller queue. The master request ID
    is determined as above, and event parameters are set to null.
  </li>
  <li>It creates a standard MDWStatusMessage as the response.
    This may not be a desired feature, so you may
    need to subclass this handler by overriding the method
    createResponseMessage().</li>
</ul>
When the process to be started is a service process (synchronous), instead of
creating the process through JMS messages and creating a standard acknowledgment
as response, it invokes the the process directly and return the value
of the variable "response" of the process as the response.
We note that service processes are invoked as a single transaction and without
using JMS messages.
<p>
  The configuration of the event handler
  in the designer has a syntax abbreviation of <code>START_PROCESS</code>,
  and requires one argument, <code>ProcessName</code>.
  The following are some examples:
<pre>
    START_PROCESS?ProcessName=MyProcess
    START_PROCESS?ProcessName=MyProcess&MasterRequestID=Order_{//OrderType}{//OrderNumber}
</pre>
<p>
  The specification of Master Request ID allows <em>place holders</em> for
  dynamic contents.
<p>
  Syntactically, a place holder is an expression enclosed by by braces ("{" and "}").
  Currently we allow either a meta parameter name preceded by a "$" (e.g <code>{$CorrelationID}</code>),
  or an <a href="xpath.html">MDW XPath expression</a> (e.g. <code>{//OrderNumber}</code>).
  In the former case, the place holder will be replaced by the
  meta parameter value passed down from the listeners.
  In the latter case, the place holder will be replaced by
  the value of applying the XPath expression to the external message.
<p>
  Specification of the Master Request ID is not required. When it is not specified,
  the external event instance ID will be used as the master request ID for the process
  instance.
<p>
  This built-in handler does not pass in any parameters
  to the process instance. If some variables need to be initialized
  from the external message, you can do so by configuring
  the start activity of the process.
  Configuration of the start activity is described with
  <a href="ProcessStartActivity.html">this link</a>.


<h3>Built-In Event Handler for Notifying Waiting Process Instances</h3>
The built-in event handler
<a href="../javadoc/com/centurylink/mdw/listener/NotifyWaitingActivityEventHandler.html">
  <code>com.centurylink.mdw.listener.NotifyWaitingActivityEventHandler</code></a> can be used
to process messages that need to be delivered to existing process instances.
<p>
  A process instance that is interested in waiting for external messages
  typically executes an <a href="EventWaitActivity.html">event wait activity</a> and must
  specify an event name, identifying the messages it waits for.
  The event handlers should take care of the tasks of mapping external messages
  to event names and inform the process instances waiting for them.
<p>
  The built-in handler can be configured through the designer as to how to
  map XML messages to event names, with the help of XPath expressions.
  Its configuration in the designer has a syntax abbreviation of <code>NOTIFY_PROCESS</code>,
  and requires one argument, <code>EventName</code>.
  Besides static text, the values of event names may contain
  place holders that will be replaced by dynamic contents.
  The syntax and semantics of place holders are the same as for
  MasterRequestID described above.
<p>
  The following are some examples:
<pre>
    NOTIFY_PROCESS?EventName=MyProcess{$CorrelationID}
    NOTIFY_PROCESS?EventName=ServiceOrder{//OrderType}{//OrderNumber}
</pre>
The event handling mechanism of MDW also takes care of the situation when
the messages arrive prior to the execution of event waiting activities.

<h2>Developing External Event Handler</h2>
External event handlers typically perform one of the followings:
<ul>
  <li>Start a process instance</li>
  <li>Inform process instances that are waiting for messages</li>
  <li>Invoke a service (synchronous) process and return the value
    of its variable "response" as response</li>
</ul>
The built-in process start event handler is a good example for
starting a process, and it is oftentimes sufficient that you use that directly
or subclass it.
<p>
  Similarly, for informing existing process instances, it is oftentimes
  sufficient that configure or subclass the built-in handler
  <a href="../javadoc/com/centurylink/mdw/listener/NotifyWaitingActivityEventHandler.html">
    <code>com.centurylink.mdw.listener.NotifyWaitingActivityEventHandler</code></a>.
<p>

  One common need for customization of starting process handler is to pass parameters (variable
  bindings) to the process. This can be achieved by subclassing <code>ProcessStartEventHandler</code>
  and override the method <code>buildParameters</code>.
  If the external message contains large data such as service orders, it is recommended
  that you create documents in this method and pass only the document references
  to the processes. The method <code>createDocument</code> defined in the base class
  can be used to create documents. See Java doc for <a href="../javadoc/com/centurylink/mdw/listener/ExternalEventHandlerBase.html">
  <code>com.centurylink.mdw.listener.ExternalEventHandlerBase</code></a>, which is the super class
  for <code>ProcessStartEventHandler</code>, for more details.
<p>
  In case you need to define your own event handlers for starting or informing
  processes, the best approach is probably to extend the class
  <a href="../javadoc/com/centurylink/mdw/listener/ExternalEventHandlerBase.html">
    <code>com.centurylink.mdw.listener.ExternalEventHandlerBase</code></a>
  instead of implementing <code>com.centurylink.mdw.event.ExternalEventHandler</code>
  from scratch. This base class contains methods to start a process, to inform (wake)
  process instances, to create a generic response message, to create a document, and so on,
  to help implementing a handler.  Please follow the hyper links above for the Javadoc.
<p>
  When informing waiting process instances using <code>ExternalEventHandlerBase.notifyProcesses()</code>,
  the event manager behind the scene will record the event, check if there is
  any process instances waiting for it, and resume them.
<p>
  To invoke a service process and return a response synchronously,
  the method to use is <code>invokeServiceProcess()</code>.



</body>
</html>